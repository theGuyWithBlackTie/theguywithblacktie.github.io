---
layout: post
title: 'The last blog you need to understand DSPy'
date: 2025-06-28 15:00 +0530
math: true
description: 'Exploring the framework for programming the large language models, not prompting'
toc: true
image:
    path: assets/headers/dspy-header.png
    alt: DSPy
hidden: true
---

With the rise of LLMs, lots of data scientists are spending ton of their time on prompt engineering to test different LLMs performances on their projects. Every week a new foundational model is released which is better and cheaper than all the previous releases, tempting all of the data scientists to test one more LLM for their projects. A satisfactory LLM testing requires ample time spent on prompt engineering to cover all the edge cases successfully, and to understand all the nuances a new LLM has. This takes weeks to be done.

In the age of AI (or automation), how about a tool that can automate the prompt engineering for data scientist while saving their time to focus on actual data science work i.e. isights generation from statistics, developing AI model architectures. That's where DSPy comes in; it offers prompt tuning for different LLMs, tuning LLM weights and AI agents.

# Introduction
[DSPy](https://github.com/stanfordnlp/dspy), pronounced as <i>dee-s-pie</i>, is developed by researcher Omar Khattab and others at <b>Stanford NLP</b> group. The [DSPy research paper](https://arxiv.org/abs/2310.03714) argues that existing LLM pipelines are typically implemented using hard-coded "prompt-temmplates" that are discovered via trial and error, whereas DSPy provides more systematic approach for developing and optimizing LLM pipelines.

## Configuring LLMs
The very first step in DSPy in initializing a language model of your choice for the future operations in the code. You can do this as follows:

```
import dspy

global_llm = dspy.LM('openai/gpt-4o-mini', api_key = <API_KEY>, temperature = 0.7, max_tokens = 3000, stop = None, cache = False)
dspy.configure(global_llm)
```

`dspy.LM` initializes the LLM of your choice and `dspy.configure` makes the initialized LLM as default LLM for the whole program. DSPy supports all the LLM providers, it can be found [here](https://dspy.ai/learn/programming/language_models/#__tabbed_1_1).

`temperature`, `cache`, `max_tokens` are some of the attributes one can configure while initializing the LLM. More attributes can be read [here](https://dspy.ai/api/models/LM/).

> By default LLMs in DSPy are cached. If you repeat the same call, you will get the same outputs. Caching can be turned off by setting `cache=False`. When using small LMs like gpt-4o-mini, you may receive the same output even with cache=False. In Jupyter Notebook, check if caching is active by observing the response timeâ€”instant responses indicate caching, while delays suggest actual LLM calls.
{: .prompt-info}

LMs configured above can be called directly as below:
```
global_llm("Classify this sentiment into either Positive, Neutral or Negative: I loved the product. The service is worst though.", temperature = 0.2)
global_llm(messages=[{
    "role": "user",
    "content": "Classify this sentiment into either Positive, Neutral or Negative: I loved the product. The service is worst though."
}], temperature = 0.5)
```

## Signatures
Prompts comprises of three parts <i>viz.</i>(a) what would be the inputs & outputs (b) describing the task and (c) prompting techniques such as <i>Chain of Thought</i>, <i>ReAct</i>, <i>Program of Thought</i>, etc. <i>Signatures</i> in DSPy is a programmatic way of defining the first two parts of prompt for your task.

There are two ways for defining <i>Signatures</i>:
- Class-based Signatures
- Inline Signatures

### Class-based Signatures
In class-based, <i>Signatures</i> has two attributes; `InputField()` to define inputs and `OutputField()` to define outputs in the prompt. The task description is declared as the <i>docstrings</i> in the `Signatures` class. Let's say we have task of sentiment classification of user reviews, the `Signature` is defined as:
```
import dspy

class SentimentSignature(dspy.Signature):
    """
    You would be given an input text; and you need to classify it into strictly these three sentiments: (a)Positive, (b)Neutral or (c)Negative.
    """
    sentiment_text = dspy.InputField()
    sentiment_classification = dspy.OutputField()
```

With the above defined signature and using standard prompting, the <i>system prompt</i> will be this:
```
Your input fields are:
1. `sentiment_text` (str):
Your output fields are:
1. `sentiment_classification` (str):
All interactions will be structured in the following way, with the appropriate values filled in.

[[ ## sentiment_text ## ]]
{sentiment_text}

[[ ## sentiment_classification ## ]]
{sentiment_classification}

[[ ## completed ## ]]
In adhering to this structure, your objective is: 
        You would be given an input text; and you need to classify it into strictly these three sentiments: (a)Positive, (b)Neutral or (c)Negative.
```

The user prompt will be this:
```
[[ ## sentiment_text ## ]]
<The input text whose sentiment need to be identified would be here>

Respond with the corresponding output fields, starting with the field `[[ ## sentiment_classification ## ]]`, and then ending with the marker for `[[ ## completed ## ]]`.
```

In the <i>system prompt</i>, `sentiment_text` and `sentiment_classification` present as these are the variables (with the same text) declared in the `SentimentSignature` signature. The <i>docstring</i> in the `SentimentSignature` class is present at the end of the <i>system prompt</i>.

### Inline Signatures
Contrary to class-based <i>Signatures</i> definition where there is class shenanigans, in inline <i>Signatures</i> are defined as a short string with argument names and optional types that define semantic roles for inputs/outputs.

For example, suppose our task is sentiment classification; the <i>Signature</i> would be: `"sentence -> sentiment: bool"` where text before the arrow `->` is input and after is output. So `sentence` is the input and `sentiment` is output.

<i>Signatures</i> in inline based definition can also have multiple inputs and outputs with types. For multiple-choice question answering with reasoning the signature will look like this: `"question: str, choices: list[str] -> reasoning: str, selection: int"`

Similar to task description through <i>docstrings</i> in class-based <i>Signatures</i> definition, we can declare the task description with `instructions` parameter as shown below:

```
toxicity = dspy.Predict(
    dspy.Signature(
        "comment -> toxic: bool",
        instructions="Mark as 'toxic' if the comment includes insults, harassment, or sarcastic derogatory remarks",
    )
)
```

> `dspy.Predict` is DSPy module which we will see in the following section.
{: .prompt-info}

## Modules
DSPy Modules are abstractions of various prompting techniques. DSPy <i>`Modules`</i> takes <i>`Signatures`</i> as their input. Following are the built-in modules supporting various prompting techniques:

1. `dspy.Predict`: It's a very basic module and it doesn't modify the <i>Signature</i>
1. `dspy.ChainOfThought` : This module support Chain Of Thought(CoT) prompting technique where LM is asked to think step-by-step before returning the response.
2. `dspy.ProgramOfThought`: This module's prompt asks LM to generate code whose execution results will dictate the response.
3. `dspy.ReAct`: This module supports ReACT prompts for AI agents.
4. `dspy.MultiChainComparison`: This module can compare multiple outputs from `ChainOfThought` to produce a final prediction.

Let's see an example of <i>`Signatures`</i> and <i>`Modules`</i> working together:

```
# Signature

import dspy

class SentimentSignature(dspy.Signature):
    """
    You would be given an input text; and you need to classify it into strictly these three sentiments: (a)Positive, (b)Neutral or (c)Negative.
    """
    sentiment_text = dspy.InputField()
    sentiment_classification = dspy.OutputField()

# Module

sentiment_classifier = dspy.Predict(SentimentSignature)

# Calling the 'classifier` 
sentiment_classifier(sentiment_classification = "I loved the product. The service is worst though.")
```

`SentimentSignature` is already explained before with its corresponding prompt. When calling the `sentiment_classifier()`, the user prompt will like this:

```
[[ ## sentiment_text ## ]]
I loved the product. The service is worst though.

Respond with the corresponding output fields, starting with the field `[[ ## sentiment_classification ## ]]`, and then ending with the marker for `[[ ## completed ## ]]`.
```
