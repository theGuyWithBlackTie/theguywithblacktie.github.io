---
layout: post
title: 'The last blog you need to understand DSPy'
date: 2025-06-28 15:00 +0530
categories: [Prompt Engineering, LLM]
math: true
description: 'Exploring the framework for programming the large language models, not prompting'
toc: true
image:
    path: assets/headers/dspy-header.png
    alt: DSPy
---

With the rise of LLMs, lots of data scientists are spending ton of their time on prompt engineering to test different LLMs performances on their projects. Every week a new foundational model is released which is better and cheaper than all the previous releases, tempting all of the data scientists to test one more LLM for their projects. A satisfactory LLM testing requires ample time spent on prompt engineering to cover all the edge cases successfully, and to understand all the nuances a new LLM has. This takes weeks to be done.

In the age of AI (or automation), how about a tool that can automate the prompt engineering for data scientist while saving their time to focus on actual data science work i.e. isights generation from statistics, developing AI model architectures. That's where DSPy comes in; it offers prompt tuning for different LLMs, tuning LLM weights and AI agents.

# Introduction
[DSPy](https://github.com/stanfordnlp/dspy), pronounced as <i>dee-s-pie</i>, is developed by researcher Omar Khattab and others at <b>Stanford NLP</b> group. The [DSPy research paper](https://arxiv.org/abs/2310.03714) argues that existing LLM pipelines are typically implemented using hard-coded "prompt-temmplates" that are discovered via trial and error, whereas DSPy provides more systematic approach for developing and optimizing LLM pipelines.

## Configuring LLMs
The very first step in DSPy in initializing a language model of your choice for the future operations in the code. You can do this as follows:

```{python}
import dspy

global_llm = dspy.LM('openai/gpt-4o-mini', api_key = <API_KEY>, temperature = 0.7, max_tokens = 3000, stop = None, cache = False)
dspy.configure(global_llm)
```
{: .nolineno }

`dspy.LM` initializes the LLM of your choice and `dspy.configure` makes the initialized LLM as default LLM for the whole program. DSPy supports all the LLM providers, it can be found [here](https://dspy.ai/learn/programming/language_models/#__tabbed_1_1).

`temperature`, `cache`, `max_tokens` are some of the attributes one can configure while initializing the LLM. More attributes can be read [here](https://dspy.ai/api/models/LM/).

> By default LLMs in DSPy are cached. If you repeat the same call, you will get the same outputs. Caching can be turned off by setting `cache=False`. When using small LMs like gpt-4o-mini, you may receive the same output even with cache=False. In Jupyter Notebook, check if caching is active by observing the response timeâ€”instant responses indicate caching, while delays suggest actual LLM calls.
{: .prompt-info}


## Signature
